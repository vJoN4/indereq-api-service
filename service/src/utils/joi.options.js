const LANG = process.env.CONFIG_LANG || 'es';

module.exports = {
  options: () => {
    let obj = {
      abortEarly: false,
      convert: true,
    };

    if (LANG === 'es') {
      obj.messages = {
        'alternatives.all': '{{#label}} no coincide con todos los tipos requeridos',
        'alternatives.any': '{{#label}} no coincide con ninguno de los tipos permitidos',
        'alternatives.match': '{{#label}} no coincide con ninguno de los tipos permitidos',
        'alternatives.one': '{{#label}} coincide con más de un tipo permitido',
        'alternatives.types': '{{#label}} debe ser uno de {{#types}}',
        'any.custom': '{{#label}} validación personalizada fallida porque {{#error.message}}',
        'any.default': '{{#label}} arrojó un error al ejecutar el método predeterminado',
        'any.failover': '{{#label}} arrojó un error al ejecutar el método de conmutación por error',
        'any.invalid': '{{#label}} contiene un valor no válido',
        'any.only': '{{#label}} debe ser {if(#valids.length == 1, "", "uno de ")}{{#valids}}',
        'any.ref': '{{#label}} {{#arg}} referente a "{{#ref}}" por {{#reason}}',
        'any.required': '{{#label}} es requerido',
        'any.unknown': '{{#label}} no está permitido',
        'array.base': '{{#label}} debe ser un arreglo',
        'array.excludes': '{{#label}} contiene un valor excluido',
        'array.hasKnown': '{{#label}} no contiene al menos una coincidencia requerida para el tipo "{#patternLabel}"',
        'array.hasUnknown': '{{#label}} no contiene al menos una coincidencia requerida',
        'array.includes': '{{#label}} no coincide con ninguno de los tipos permitidos',
        'array.includesRequiredBoth': '{{#label}} no contiene {{#knownMisses}} y {{#unknownMisses}} otros valores requeridos',
        'array.includesRequiredKnowns': '{{#label}} no contiene {{#knownMisses}}',
        'array.includesRequiredUnknowns': '{{#label}} no contiene {{#unknownMisses}} los valores requeridos',
        'array.length': '{{#label}} debe contener {{#limit}} elementos',
        'array.max': '{{#label}} debe contener menos o igual a {{#limit}} elementos',
        'array.min': '{{#label}} debe contener al menos {{#limit}} elementos',
        'array.orderedLength': '{{#label}} debe contener como máximo {{#limit}} elementos',
        'array.sort': '{{#label}} deben ordenarse en {#order} ordenado por {{#by}}',
        'array.sort.mismatching': '{{#label}} no se puede ordenar debido a que los tipos no coinciden',
        'array.sort.unsupported': '{{#label}} no se puede ordenar debido a un tipo no compatible a {#type}',
        'array.sparse': '{{#label}} no debe ser un elemento de matriz disperso',
        'array.unique': '{{#label}} contiene un valor duplicado',
        'binary.base': '{{#label}} debe ser un búfer o una cadena',
        'binary.length': '{{#label}} debe tener {{#limit}} bytes',
        'binary.max': '{{#label}} debe ser menor o igual que {{#limit}} bytes',
        'binary.min': '{{#label}} debe ser por lo menos {{#limit}} bytes',
        'boolean.base': '{{#label}} debe ser un booleano',
        'date.base': '{{#label}} debe ser una fecha válida',
        'date.format': '{{#label}} debe estar en el formato {msg("date.format." + #format) || #format}',
        'date.format.iso': 'Formato ISO 8601',
        'date.format.javascript': 'marca de tiempo o número de milisegundos',
        'date.format.unix': 'marca de tiempo o número de segundos',
        'date.greater': '{{#label}} debe ser mayor que "{{#limit}}"',
        'date.less': '{{#label}} debe ser menor que "{{#limit}}"',
        'date.max': '{{#label}} debe ser menor o igual que "{{#limit}}"',
        'date.min': '{{#label}} debe ser mayor o igual que "{{#limit}}"',
        'function.arity': '{{#label}} debe tener una aridad de {{#n}}',
        'function.class': '{{#label}} debe ser una clase',
        'function.maxArity': '{{#label}} debe tener una aridad menor o igual a {{#n}}',
        'function.minArity': '{{#label}} debe tener una aridad mayor o igual a {{#n}}',
        'number.base': '{{#label}} tiene que ser un número',
        'number.greater': '{{#label}} debe ser mayor que {{#limit}}',
        'number.infinity': '{{#label}} no puede ser infinito',
        'number.integer': '{{#label}} debe ser un entero',
        'number.less': '{{#label}} debe ser menor que {{#limit}}',
        'number.max': '{{#label}} debe ser menor o igual que {{#limit}}',
        'number.min': '{{#label}} debe ser mayor o igual que {{#limit}}',
        'number.multiple': '{{#label}} debe ser un múltiplo de {{#multiple}}',
        'number.negative': '{{#label}} debe ser un número negativo',
        'number.port': '{{#label}} debe ser un puerto válido',
        'number.positive': '{{#label}} debe ser un número positivo',
        'number.precision': '{{#label}} no debe tener más de {{#limit}} decimales',
        'number.unsafe': '{{#label}} debe ser un número seguro',
        'object.and': '{{#label}} contiene {{#presentWithLabels}} sin el par de {{#missingWithLabels}}',
        'object.assert': '{{#label}} es invalido porque {if(#subject.key, `"` + #subject.key + `" falló al ` + (#message || "pasar la prueba de aserción"), #message || "la aserción falló")}',
        'object.base': '{{#label}} debe ser de tipo {{#type}}',
        'object.instance': '{{#label}} debe ser una instancia de "{{#type}}"',
        'object.length': '{{#label}} debe tener {{#limit}} key{if(#limit == 1, "", "s")}',
        'object.max': '{{#label}} debe tener menor o igual a {{#limit}} key{if(#limit == 1, "", "s")}',
        'object.min': '{{#label}} debe tener al menos {{#limit}} key{if(#limit == 1, "", "s")}',
        'object.missing': '{{#label}} debe contener al menos uno de {{#peersWithLabels}}',
        'object.nand': '"{{#mainWithLabel}}" no debe existir simultáneamente con {{#peersWithLabels}}',
        'object.oxor': '{{#label}} contiene un conflicto entre pares exclusivos opcionales {{#peersWithLabels}}',
        'object.pattern.match': '{{#label}} las claves no coincidieron con los requisitos del patrón',
        'object.refType': '{{#label}} debe ser una referencia de Joi',
        'object.regex': '{{#label}} debe ser un objeto RegExp',
        'object.rename.multiple': '{{#label}} no se puede cambiar el nombre de "{{#from}}" porque varios cambios de nombre están deshabilitados y otra clave ya se cambió a "{{#to}}"',
        'object.rename.override': '{{#label}} no se puede cambiar el nombre de "{{#from}}" porque la anulación está deshabilitada y el objetivo "{{#to}}" existe',
        'object.schema': '{{#label}} debe ser un esquema Joi de tipo {{#type}}',
        'object.unknown': '{{#label}} no se permite',
        'object.with': '"{{#mainWithLabel}}" par requerido faltante "{{#peerWithLabel}}"',
        'object.without': '"{{#mainWithLabel}}" conflicto con un par prohibido "{{#peerWithLabel}}"',
        'object.xor': '{{#label}} contiene un conflicto entre pares exclusivos {{#peersWithLabels}}',
        'string.alphanum': '{{#label}} solo debe contener caracteres alfanuméricos',
        'string.base': '{{#label}} debe ser una cadena',
        'string.base64': '{{#label}} debe ser una cadena base64 válida',
        'string.creditCard': '{{#label}} debe ser una tarjeta de crédito',
        'string.dataUri': '{{#label}} debe ser una cadena dataUri válida',
        'string.domain': '{{#label}} debe contener un nombre de dominio válido',
        'string.email': '{{#label}} debe ser un correo electrónico válido',
        'string.empty': '{{#label}} no está permitido estar vacío',
        'string.guid': '{{#label}} debe ser un GUID válido',
        'string.hex': '{{#label}} solo debe contener caracteres hexadecimales',
        'string.hexAlign': '{{#label}} la representación decodificada hexadecimal debe estar alineada por bytes',
        'string.hostname': '{{#label}} debe ser un nombre de host válido',
        'string.ip': '{{#label}} debe ser una dirección IP válida con un CIDR {{#cidr}}',
        'string.ipVersion': '{{#label}} debe ser una dirección IP válida de una de las siguientes versiones {{#version}} con un CIDR {{#cidr}}',
        'string.isoDate': '{{#label}} debe estar en formato ISO',
        'string.isoDuration': '{{#label}} debe tener una duración ISO 8601 válida',
        'string.length': '{{#label}} la longitud debe tener un tamaño de {{#limit}} caracteres',
        'string.lowercase': '{{#label}} solo debe contener caracteres en minúscula',
        'string.max': 'El tamaño de {{#label}} debe ser menor o igual que {{#limit}} caracteres',
        'string.min': 'El tamaño de {{#label}} debe ser por lo menos de {{#limit}} caracteres',
        'string.normalize': '{{#label}} debe estar normalizado en formato unicode en el formulario {{#form}}',
        'string.pattern.base': '{{#label}} no coincide con el valor "{[.]}" con el patrón requerido: {{#regex}}',
        'string.pattern.invert.base': '{{#label}} con el valor "{[.]}" coincide con el patrón invertido: {{#regex}}',
        'string.pattern.invert.name': '{{#label}} con el valor "{[.]}" coincide con el patrón invertido {{#name}}',
        'string.pattern.name': '{{#label}} no coincide con el valor "{[.]}" con el patrón {{#name}}',
        'string.token': '{{#label}} solo debe contener caracteres alfanuméricos y de subrayado',
        'string.trim': '{{#label}} no debe tener espacios en blanco iniciales o finales',
        'string.uppercase': '{{#label}} solo debe contener caracteres en mayúscula',
        'string.uri': '{{#label}} debe ser un URI válido',
        'string.uriCustomScheme': '{{#label}} debe ser un URI válido con un esquema que coincida con el patrón {{#scheme}}',
        'string.uriRelativeOnly': '{{#label}} debe ser un URL relativa válida',
        'symbol.base': '{{#label}} debe ser un símbolo',
        'symbol.map': '{{#label}} debe ser uno de {{#map}}',
      };
    }

    return obj;
  },
};
